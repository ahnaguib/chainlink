pragma solidity 0.4.24;

/* VRF implements on-chain verification of verifiable-random-function (VRF)
 * proofs, approximately as described in these documents:
 * https://tools.ietf.org/html/draft-goldbe-vrf-01#section-4.1 (spec)
 * https://eprint.iacr.org/2017/099.pdf (security proofs).
 *
 * See vrf.go package comment for description and justification of the
 * differences, which are mostly motivated by efficiency for this contract.
 *
 * Purpose
 * -------
 *
 * Reggie the Random Oracle (not his real job) wants to provide randomness to
 * Vera the verifier in such a way that Vera can be sure he's not making his
 * output up to suit himself. Reggie provides Vera an RSA public key to which he
 * knows the secret key. Each time Vera provides a seed to Reggie, he gives back
 * a value which is deterministically computed from the seed and the secret key,
 * but which is indistinguishable from uniform random sampling from Vera's
 * perspective, because she does not know the secret. Nonetheless, Vera is able
 * to verify that Reggie's output came from her seed and his secret key.
 *
 * The purpose of this contract is to perform that verification.
 *
 * Usage
 *------
 *
 * Deploy the contract with Reggie's public key modulus, as a big-endian uint256
 * array whose total bit length equals keySizeBits. Reggie should make his
 * public key using vrf.go/MakeKey. Its public exponent should match the
 * publicExponent constant below, and the bit-size of its public modulus should
 * match keySizeBits.
 *
 * The main entry point is isValidVRFOutput. Pass it the fields of a vrf.Proof
 * object generated by vrf.go/GenerateProof. The Proof.Decryption field should
 * be passed as a big-endian uint256 array.
 *
 * Returns true iff the proof can be verified as showing that _output was
 * generated as mandated from the given _seed.
 *
 * See the definition of checkProof, in VRF_test.js, for an example invocation.
 */

contract VRF {

  uint256 constant keySizeBits = 2048;  // Size of RSA modulus
  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant keySizeWords = keySizeBits / 256;
  // The traditional public key
  //
  // A publicExponent of 3 drastically reduces gas costs. See gasCost.
  uint256 constant publicExponent = 3;
  uint256[keySizeWords] public modulus;  // Set in constructor

  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant keySizeBytes = keySizeBits / 8;

  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant topUintBit = 1 << 255;
  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant allBitsExceptTop = topUintBit - 1;

  // _RSAModulus must be in big-endian format
  constructor(uint256[keySizeWords] memory _RSAModulus) public {
    require(publicExponent == 3, "Changed exponent; adjust gasCost calculation");
    require(keySizeBits % 256 == 0, "Key size must be multiple of 256 bits.");
    require(_RSAModulus[0] & topUintBit == topUintBit, "modulus length must match key size");
    modulus = _RSAModulus;
  }

  // solium-disable-next-line zeppelin/no-arithmetic-operations 
  uint256 constant wordSizeBytes = 256 / 8; 

  // Used in gas cost for bigModExp precompiled contract call. For formula, see
  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-198.md#specification
  uint256 constant GQUADDIVISOR = 20; // Constant specified in EIP 198
  // Exponent of 3 results in ADJUSTED_EXPONENT_LENGTH of 1, so it can be
  // excluded from the calculation.
  uint256 constant gasCost = // solium-disable-next-line zeppelin/no-arithmetic-operations 
    ((keySizeBytes ** 2) / 4 + 96 * keySizeBytes - 3072) / GQUADDIVISOR;  // solium-disable-line indentation

  // Memory layout for call to bigModExp precompiled contract
  uint256 constant inputLengths = 3; // one word each for lengths of args
  uint256 constant baseLength = keySizeWords;
  uint256 constant exponentLength = 1; // one word for exponent
  uint256 constant modulusLength = keySizeWords;
  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant inputSizeWords = inputLengths + baseLength + exponentLength + modulusLength;
  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant inputSizeBytes = inputSizeWords * wordSizeBytes;

  // (_base**exponent) % modulus. _base must be in big-endian format. Return
  // value is big-endian.
  function bigModExp(uint256[keySizeWords] memory _base)
    public view returns(uint256[keySizeWords] memory result) {
    // Lay out the arguments in memory as bigModExp expects them:
    //
    // base-length||exponent-length||modulus-length||   base     ||publicExponent||modulus
    //   1 word   ||    1 word     ||   1 word     ||keySizeBytes||    1 word    ||keySizeBytes
    //
    // Units for length arguments are bytes, all numbers are big-endian format.
    uint256[inputSizeWords] memory inputs;
    uint256 currentInput = 0;
    inputs[currentInput++] = keySizeBytes;  // _base length
    inputs[currentInput++] = wordSizeBytes; // exponent length
    inputs[currentInput++] = keySizeBytes;  // modulus length
    for (uint256 i = 0 ; i < keySizeWords; i++) {
      inputs[currentInput++] = _base[i];
    }
    inputs[currentInput++] = publicExponent;
    for (i = 0 ; i < keySizeWords; i++) {
      inputs[currentInput++] = modulus[i];
    }
    assert(currentInput == inputSizeWords); 

    // Now, do the bigModExp
    uint256 inputsLength = inputSizeBytes; // No constants in assembly
    uint256 resultsLength = keySizeBytes;  // No constants in assembly
    uint256 gcost = gasCost;               // No constants in assembly
    int success = 0;
    assembly{
      result := mload(0x40)  // Store result at start of free memory
      mstore(0x40, add(result, resultsLength))  // Move freemem ptr past result
      success := staticcall(
        gcost,
        0x05,                  // BigModExp contract address
        inputs, inputsLength,  // Input segment
        result, resultsLength) // Output segment
    }
    if (success == 0) {revert("bigModExp call failed");}
  }

  // true iff _output is the hash of _decryption, which is the value mandated by
  // modulus and _seed
  function isValidVRFOutput(
    uint256 _seed,  uint256[keySizeWords] memory _decryption, uint256 _output)
    public view returns (bool) {
    // Corresponds to vrf.go/decryptionToOutput.
    if (_output != uint256(keccak256(abi.encodePacked(_decryption)))) {
      return false;
    }
    // Corresponds to vrf.go/seedToRingValue
    uint256[keySizeWords] memory expectedEncryption;
    expectedEncryption[0] = uint256(keccak256(abi.encodePacked(_seed)));
    for (uint256 i = 1; i < keySizeWords; i++) {
      // solium-disable-next-line zeppelin/no-arithmetic-operations
      expectedEncryption[i] = uint256(keccak256(abi.encodePacked(expectedEncryption[i-1]))); 
    }
    expectedEncryption[0] &= allBitsExceptTop; // Turn off top bit
    // Verify _decryption encrypts to value produced by vrf.go/seedToRingValue
    // for this seed and key.
    uint256[keySizeWords] memory actualEncryption = bigModExp(_decryption);
    for (i = 0; i < keySizeWords; i++) {
      if (actualEncryption[i] != expectedEncryption[i]) {
        return false;
      }
    }
    return true;
  }
  // TODO(alx): Unroll the loops and hard-code the array indices, to save gas.
}
